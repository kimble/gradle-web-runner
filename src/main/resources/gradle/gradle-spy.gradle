import groovy.json.JsonOutput



class BuildSpy {

    ServerSocket serverSocket
    Socket socket
    Writer socketWriter

    BuildSpy(int port) {
        try {
            serverSocket = new ServerSocket(port)
        }
        catch (IOException ex) {
            throw new GradleException("Unable to listen to port " + port, ex)
        }

        socket = serverSocket.accept()
        OutputStream bufferedSocketOutputStream = new BufferedOutputStream(socket.outputStream)
        socketWriter = bufferedSocketOutputStream.newWriter("utf-8")
    }

    synchronized void send(String type, Object payload) {
        try {
            socketWriter.write(JsonOutput.toJson([
                    type: type,
                    event: payload
            ]) + "\n----====----\n")
        }
        catch (Exception ex) {
            throw new GradleException("failed to send message '$type': <$payload>", ex)
        }
    }

    void terminate() {
        try {
            socketWriter.close()
        }
        finally {
            serverSocket.close()
        }
    }

}


String spyPort = System.getenv("SPY_PORT")

if (!spyPort) {
    throw new GradleException("No environment variable SPY_PORT set")
}


logger.lifecycle "Gradle build spy starting on port $spyPort"
new Thread({
    Thread.sleep(500) // Give some time for the port to open
    // - The client on the other end will listen for the following message.
    logger.lifecycle "I'll be hanging around waiting for the backend to connect.."
}).start()

BuildSpy spy = new BuildSpy(Integer.parseInt(spyPort))



def printExceptionToString = { Throwable trouble ->
    if (trouble != null) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        trouble?.printStackTrace(pw);

        return sw.toString();
    }
    else {
        return null;
    }
}

// Gradle event listeners

gradle.projectsLoaded { gradle ->
    gradle.ext.buildStarted = System.currentTimeMillis()
}

gradle.beforeProject { Project project ->
    spy.send("evaluating-project", [
            name: project.name,
            path: project.path,
            description: project.description
    ])
}

gradle.afterProject { Project project, evaluationFailure ->
    spy.send("project-evaluated", [
            name: project.name,
            path: project.path,
            description: project.description,

            parent: project.parent?.path,
            children: project.childProjects.values().collect { it.path }
    ]);
}

gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
    spy.send("task-graph-ready",
            [
                    tasks: graph.allTasks.collect { Task task ->
                        [
                                projectPath: task.project.path,
                                type: task.class.simpleName.replace("_Decorated", ""),
                                group: task.group,
                                name: task.name,
                                path: task.path,
                                description: task.description,
                                dependsOn: task.taskDependencies.getDependencies(task).collect { it.path }
                        ]
                    }
            ]
    )

    /**
     * Attach listeners for test execution and output
     * (leveraging Gradle's framework agnostic api)
     */
    graph.allTasks.forEach { Task task ->
        if (task instanceof Test) {

            task.doFirst {
                task.ext.testOutput = [:]
            }

            task.doLast {
                task.ext.testOutput = null
            }

            // Before
            task.beforeTest { TestDescriptor test ->
                spy.send("before-test", [
                        name: test.name,
                        className: test.className,
                        projectPath: task.project.path,
                        taskPath: task.path
                ])
            }

            // During
            task.onOutput { TestDescriptor test, TestOutputEvent outputEvent ->
                final id = test.className + ":" + test.name

                if (!task.testOutput[id]) {
                    task.testOutput[id] = []
                }

                task.testOutput[id] << outputEvent.message // Todo: Store outputEvent.destination somehow? (keep track of output to std.err)
            }

            // After
            task.afterTest { TestDescriptor test, TestResult result ->
                spy.send("after-test", [
                        name: test.name,
                        className: test.className,
                        taskPath: task.path,
                        result: result.resultType.name(),
                        durationMillis: result.endTime - result.startTime,
                        exceptionMessage: result.exception?.message,
                        exceptionStacktrace: printExceptionToString(result.exception),
                        output: task.testOutput[test.className + ":" + test.name]
                ])
            }
        }
    }

    graph.beforeTask { Task task ->
        task.ext.startTime = System.currentTimeMillis()

        spy.send("task-before", [
                path: task.path,
                projectPath: task.project.path,
                timestamp: task.ext.startTime,
                threadName: Thread.currentThread().name
        ])
    }

    graph.afterTask { Task task, TaskState state ->
        long timestamp = System.currentTimeMillis()

        spy.send("task-after", [
                path: task.path,
                projectPath: task.project.path,
                timestamp: timestamp,
                didWork: state.didWork,
                executed: state.executed,
                skipped: state.skipped,
                skippedMessage: state.skipMessage,
                failureMessage: state.failure?.message,
                failureStacktrace: printExceptionToString(state.failure),
                durationMillis: timestamp - task.ext.startTime
        ])
    }
}


gradle.settingsEvaluated { Settings settings ->
    spy.send("settings-ready", [
            timestamp: System.currentTimeMillis(),
            settings: [
                    projectName: settings.rootProject.name,
                    parallelExecution: settings.startParameter.hasProperty("parallelProjectExecutionEnabled") ? settings.startParameter.parallelProjectExecutionEnabled : false,
                    maxWorkerCount: settings.startParameter.hasProperty("maxWorkerCount") ? settings.startParameter.maxWorkerCount : 1,
                    configureOnDemand: settings.startParameter.hasProperty("configureOnDemand") ? settings.startParameter.configureOnDemand : false,
                    gradleVersion: settings.gradle.gradleVersion,
                    taskNames: settings.gradle.startParameter.taskNames,
                    directory: gradle.startParameter.currentDir.absolutePath
            ]
    ])
}



gradle.buildFinished { BuildResult result ->
    try {
        spy.send("build-completed", [
                failureMessage: result.failure?.message,
                durationMillis: System.currentTimeMillis() - result.gradle.buildStarted,
                timestamp: System.currentTimeMillis()
        ]);
    }
    finally {
        logger.lifecycle "Terminating build spy"
        spy.terminate()
    }
}




