import groovy.json.JsonOutput



class BuildSpy {

    ServerSocket serverSocket
    Socket socket
    Writer socketWriter

    BuildSpy(int port) {
        try {
            serverSocket = new ServerSocket(port);
        }
        catch (IOException ex) {
            throw new GradleException("Unable to listen to port " + port, ex)
        }

        socket = serverSocket.accept()
        OutputStream bufferedSocketOutputStream = new BufferedOutputStream(socket.outputStream)
        socketWriter = bufferedSocketOutputStream.newWriter("utf-8")
    }

    synchronized void send(String key, Object payload) {
        try {
            socketWriter.write(JsonOutput.toJson([
                    type: key,
                    event: payload
            ]) + "\n")
        }
        catch (Exception ex) {
            throw new GradleException("failed to send message", ex)
        }
    }

    void terminate() {
        socketWriter.close()
    }

}


String spyPort = System.getenv("SPY_PORT")

if (!spyPort) {
    throw new GradleException("No environment variable SPY_PORT set")
}


logger.lifecycle "Gradle build spy starting on port $spyPort"
new Thread({
    Thread.sleep(500) // Gi litt tid til å åpne porten
    logger.lifecycle "I'll be hanging around waiting for the g-viz to connect.."
}).start()

BuildSpy spy = new BuildSpy(Integer.parseInt(spyPort))




gradle.addListener(new BuildListener() {

    void buildStarted(Gradle gradle) {
    }

    void settingsEvaluated(Settings settings) {
        spy.send("settings-ready", [
                settings: [
                    projectName: settings.rootProject.name,
                    parallelProjectExecution: settings.startParameter.parallelProjectExecutionEnabled,
                    maxWorkerCount: settings.startParameter.maxWorkerCount,
                    configureOnDemand: settings.startParameter.configureOnDemand,
                    gradleUserHomeDir: settings.startParameter.gradleUserHomeDir?.absolutePath,
                    projectDir: settings.startParameter.projectDir?.absolutePath,
                    gradleVersion: settings.gradle.gradleVersion
                ]
        ])
    }

    void projectsLoaded(Gradle gradle) {
        // Used to store test output as we receive it
        // Replace this with a Task metaclass property?
        def testOutput = [:]


        gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
            spy.send("task-graph-ready",
                    [
                        tasks: graph.allTasks.collect { Task task ->
                            [
                                    name: task.name,
                                    path: task.path,
                                    description: task.description,
                                    dependsOn: task.taskDependencies.getDependencies(task).collect { it.path }
                            ]
                    }
                ]
            )

            /**
             * Attach listeners for test execution and output
             * (leveraging Gradle's framework agnostic api)
             */
            graph.allTasks.forEach { Task task ->
                if (task instanceof Test) {
                    task.addTestOutputListener(new TestOutputListener() {

                        @Override
                        void onOutput(TestDescriptor testDescriptor, TestOutputEvent outputEvent) {
                            synchronized (testOutput) {
                                def key = testDescriptor.className + ":" + testDescriptor.name
                                if (!testOutput.containsKey(key)) {
                                    testOutput[key] = []
                                }

                                testOutput[key] << outputEvent.destination.name() + ": " + outputEvent.message
                            }
                        }

                    })

                    task.addTestListener(new TestListener() {

                        @Override
                        void beforeSuite(TestDescriptor suite) { }

                        @Override
                        void afterSuite(TestDescriptor suite, TestResult result) { }

                        @Override
                        void beforeTest(TestDescriptor testDescriptor) {
                            spy.send("before-test", [
                                    name: testDescriptor.name,
                                    className: testDescriptor.className
                            ])
                        }

                        @Override
                        void afterTest(TestDescriptor testDescriptor, TestResult result) {
                            synchronized (testOutput) {
                                spy.send("after-test", [
                                        name: testDescriptor.name,
                                        className: testDescriptor.className,
                                        result: result.resultType.name(),
                                        durationMillis: result.endTime - result.startTime,
                                        exceptionMessage: result.exception?.message,
                                        output: testOutput.remove(testDescriptor.className + ":" + testDescriptor.name)
                                ])
                            }
                        }

                    })
                }
            }
        }




        gradle.taskGraph.addTaskExecutionListener(new TaskExecutionListener() {

            Map<String, Long> taskStartTime = [:]

            @Override
            void beforeExecute(Task task) {
                taskStartTime[task.path] = System.currentTimeMillis()

                spy.send("task-before", [
                        path: task.path,
                        timestamp: taskStartTime[task.path]
                ])
            }

            @Override
            void afterExecute(Task task, TaskState state) {
                spy.send("task-after", [
                        path: task.path,
                        didWork: state.didWork,
                        executed: state.executed,
                        skipped: state.skipped,
                        skippedMessage: state.skipMessage,
                        failureMessage: state.failure?.message,
                        durationMillis: System.currentTimeMillis() - taskStartTime[task.path]
                ])
            }

        })
    }

    void projectsEvaluated(Gradle gradle) { }

    void buildFinished(BuildResult result) {
        spy.send("build-completed", [
                failureMessage: result.failure?.message,
                timestamp: System.currentTimeMillis()
        ]);


        logger.lifecycle "Terminating build spy"
        spy.terminate()
    }

})

