import groovy.json.JsonOutput



class BuildSpy {

    ServerSocket serverSocket
    Socket socket
    Writer socketWriter

    BuildSpy(int port) {
        try {
            serverSocket = new ServerSocket(port)
        }
        catch (IOException ex) {
            throw new GradleException("Unable to listen to port " + port, ex)
        }

        socket = serverSocket.accept()
        OutputStream bufferedSocketOutputStream = new BufferedOutputStream(socket.outputStream)
        socketWriter = bufferedSocketOutputStream.newWriter("utf-8")
    }

    synchronized void send(String type, Object payload) {
        try {
            socketWriter.write(JsonOutput.toJson([
                    type: type,
                    event: payload
            ]) + "\n----====----\n")
        }
        catch (Exception ex) {
            throw new GradleException("failed to send message '$type': <$payload>", ex)
        }
    }

    void terminate() {
        try {
            socketWriter.close()
        }
        finally {
            serverSocket.close()
        }
    }

}


String spyPort = System.getenv("SPY_PORT")

if (!spyPort) {
    throw new GradleException("No environment variable SPY_PORT set")
}


logger.lifecycle "Gradle build spy starting on port $spyPort"
new Thread({
    Thread.sleep(500) // Give some time for the port to open
    // - The client on the other end will listen for the following message.
    logger.lifecycle "I'll be hanging around waiting for the backend to connect.."
}).start()

BuildSpy spy = new BuildSpy(Integer.parseInt(spyPort))





// Gradle event listeners

gradle.projectsLoaded { gradle ->
    gradle.ext.buildStarted = System.currentTimeMillis()
}

gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
    spy.send("task-graph-ready",
            [
                    tasks: graph.allTasks.collect { Task task ->
                        [
                                type: task.class.simpleName.replace("_Decorated", ""),
                                name: task.name,
                                path: task.path,
                                description: task.description,
                                dependsOn: task.taskDependencies.getDependencies(task).collect { it.path }
                        ]
                    }
            ]
    )

    /**
     * Attach listeners for test execution and output
     * (leveraging Gradle's framework agnostic api)
     */
    graph.allTasks.forEach { Task task ->
        if (task instanceof Test) {

            task.doFirst {
                task.ext.testOutput = [:]
            }

            task.doLast {
                task.ext.testOutput = null
            }

            // Before
            task.beforeTest { TestDescriptor test ->
                spy.send("before-test", [
                        name: test.name,
                        className: test.className
                ])
            }

            // During
            task.onOutput { TestDescriptor test, TestOutputEvent outputEvent ->
                final id = test.className + ":" + test.name

                if (!task.testOutput[id]) {
                    task.testOutput[id] = []
                }

                task.testOutput[id] << outputEvent.message // Todo: Store outputEvent.destination somehow? (keep track of output to std.err)
            }

            // After
            task.afterTest { TestDescriptor test, TestResult result ->
                StringWriter sw = new StringWriter();
                PrintWriter pw = new PrintWriter(sw);
                result.exception?.printStackTrace(pw);

                spy.send("after-test", [
                        name: test.name,
                        className: test.className,
                        result: result.resultType.name(),
                        durationMillis: result.endTime - result.startTime,
                        exceptionMessage: result.exception?.message,
                        exceptionStacktrace: sw.toString(),
                        output: task.testOutput[test.className + ":" + test.name]
                ])
            }
        }
    }

    graph.beforeTask { Task task ->
        task.ext.startTime = System.currentTimeMillis()

        spy.send("task-before", [
                path: task.path,
                timestamp: task.ext.startTime
        ])
    }

    graph.afterTask { Task task, TaskState state ->
        spy.send("task-after", [
                path: task.path,
                didWork: state.didWork,
                executed: state.executed,
                skipped: state.skipped,
                skippedMessage: state.skipMessage,
                failureMessage: state.failure?.message,
                durationMillis: System.currentTimeMillis() - task.ext.startTime
        ])
    }
}


gradle.settingsEvaluated { Settings settings ->
    spy.send("settings-ready", [
            settings: [
                    projectName: settings.rootProject.name,
                    parallelExecution: settings.startParameter.parallelProjectExecutionEnabled,
                    maxWorkerCount: settings.startParameter.maxWorkerCount,
                    configureOnDemand: settings.startParameter.configureOnDemand,
                    gradleVersion: settings.gradle.gradleVersion
            ]
    ])
}



gradle.buildFinished { BuildResult result ->
    try {
        spy.send("build-completed", [
                failureMessage: result.failure?.message,
                durationMillis: System.currentTimeMillis() - result.gradle.buildStarted,
                timestamp: System.currentTimeMillis()
        ]);
    }
    finally {
        logger.lifecycle "Terminating build spy"
        spy.terminate()
    }
}




