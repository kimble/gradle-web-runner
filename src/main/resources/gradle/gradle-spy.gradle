import groovy.json.JsonOutput

class BuildSpy {

    ServerSocket serverSocket
    Socket socket
    Writer socketWriter

    BuildSpy(int port) {
        try {
            serverSocket = new ServerSocket(port);
        }
        catch (IOException ex) {
            throw new GradleException("Unable to listen to port " + port, ex)
        }

        socket = serverSocket.accept()
        socketWriter = socket.outputStream.newWriter("utf-8")
    }

    synchronized void send(String key, Object payload) {
        try {
            socketWriter.write(JsonOutput.toJson([
                    type: key,
                    event: payload
            ]) + "\n")

            // socketWriter.flush() // UnÃ¸dvendig?
            // Thread.sleep(20); // REMOVE ME
        }
        catch (Exception ex) {
            throw new GradleException("failed to send message", ex)
        }
    }

}


String spyPort = System.getenv("SPY_PORT")

if (!spyPort) {
    throw new GradleException("No environment variable SPY_PORT set")
}


logger.lifecycle "Gradle build spy started on port $spyPort"
logger.lifecycle "I'll be hanging around waiting for the g-viz to connect.."
BuildSpy spy = new BuildSpy(Integer.parseInt(spyPort))




gradle.addListener(new BuildListener() {

    void buildStarted(Gradle gradle) {
        logger.lifecycle "BUILD STARTED"
    }

    void settingsEvaluated(Settings settings) {
        logger.lifecycle "SETTINGS EVALUATED"

        spy.send("settings-ready", [
                projectName: settings.rootProject.name,
                parallelProjectExecutionEnabled: settings.startParameter.parallelProjectExecutionEnabled,
                maxWorkerCount: settings.startParameter.maxWorkerCount,
                configureOnDemand: settings.startParameter.configureOnDemand,
                gradleUserHomeDir: settings.startParameter.gradleUserHomeDir,
                projectDir: settings.startParameter.projectDir,
                gradleVersion: settings.gradle.gradleVersion
        ]);
    }

    void projectsLoaded(Gradle gradle) {
        logger.lifecycle "PROJECTS LOADED"


        // Used to store test output as we receive it
        def testOutput = [:]


        gradle.taskGraph.whenReady { TaskExecutionGraph graph ->
            spy.send("task-graph-ready", graph.allTasks.collect { Task task ->
                [
                        name: task.name,
                        path: task.path,
                        description: task.description,
                        dependsOn: task.taskDependencies.getDependencies(task).collect { it.path }
                ]
            })

            /**
             * Attach listeners for test execution and output
             * (leveraging Gradle's framework agnostic api)
             */
            graph.allTasks.forEach { Task task ->
                if (task instanceof Test) {
                    task.addTestOutputListener(new TestOutputListener() {

                        @Override
                        void onOutput(TestDescriptor testDescriptor, TestOutputEvent outputEvent) {
                            synchronized (testOutput) {
                                def key = testDescriptor.className + ":" + testDescriptor.name
                                if (!testOutput.containsKey(key)) {
                                    testOutput[key] = []
                                }

                                testOutput[key] << outputEvent.destination.name() + ": " + outputEvent.message
                            }
                        }

                    })

                    task.addTestListener(new TestListener() {

                        @Override
                        void beforeSuite(TestDescriptor suite) { }

                        @Override
                        void afterSuite(TestDescriptor suite, TestResult result) { }

                        @Override
                        void beforeTest(TestDescriptor testDescriptor) {
                            spy.send("before-test", [
                                    name: testDescriptor.name,
                                    className: testDescriptor.className
                            ])
                        }

                        @Override
                        void afterTest(TestDescriptor testDescriptor, TestResult result) {
                            synchronized (testOutput) {
                                spy.send("after-test", [
                                        name: testDescriptor.name,
                                        className: testDescriptor.className,
                                        result: result.resultType.name(),
                                        durationMillis: result.endTime - result.startTime,
                                        exceptionMessage: result.exception?.message,
                                        output: testOutput.remove(testDescriptor.className + ":" + testDescriptor.name)
                                ])
                            }
                        }

                    })
                }
            }
        }




        gradle.taskGraph.addTaskExecutionListener(new TaskExecutionListener() {

            Map<String, Long> taskStartTime = [:]

            @Override
            void beforeExecute(Task task) {
                taskStartTime[task.path] = System.currentTimeMillis()

                spy.send("before-task", [
                        path: task.path,
                        timestamp: taskStartTime[task.path]
                ])
            }

            @Override
            void afterExecute(Task task, TaskState state) {
                spy.send("after-task", [
                        path: task.path,
                        didWork: state.didWork,
                        executed: state.executed,
                        skipped: state.skipped,
                        skippedMessage: state.skipMessage,
                        failureMessage: state.failure?.message,
                        duration: System.currentTimeMillis() - taskStartTime[task.path]
                ])
            }

        })
    }

    void projectsEvaluated(Gradle gradle) {
        logger.lifecycle "PROJECTS EVALUATED"
    }

    void buildFinished(BuildResult result) {
        logger.lifecycle "BUILD FINISHED"

        spy.send("build-finished", [
                failureMessage: result.failure?.message,
                timestamp: System.currentTimeMillis()
        ]);
    }

})

